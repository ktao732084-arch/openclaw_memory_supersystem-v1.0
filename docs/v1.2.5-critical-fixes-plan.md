# Memory System v1.2.5 - å…³é”®ç¼ºé™·ä¿®å¤æ–¹æ¡ˆ

## ğŸ”¥ å®¡è®¡å‘ç°çš„è‡´å‘½é—®é¢˜

åŸºäº Crabby çš„æ·±åº¦å®¡è®¡ï¼Œå‘ç° 5 ä¸ªæ¶æ„çº§ç¼ºé™·ï¼š

| é—®é¢˜ | ä¸¥é‡æ€§ | å½±å“ |
|------|--------|------|
| 1. å¹¶å‘æ­»é”é£é™© | ğŸ”´ Critical | é«˜å³°æœŸå´©æºƒ |
| 2. è¡°å‡é€»è¾‘å¤±æ•ˆ | ğŸ”´ Critical | æ£€ç´¢è´¨é‡é€€åŒ– |
| 3. SQL æ³¨å…¥é£é™© | ğŸŸ¡ High | æ•°æ®åº“è¢«æ¸…ç©º |
| 4. ç¬›å¡å°”ç§¯é™·é˜± | ğŸŸ¡ High | æ€§èƒ½é€€åŒ– |
| 5. ç‰ˆæœ¬ç®¡ç†ç¼ºå¤± | ğŸŸ  Medium | å‡çº§å›°éš¾ |

---

## ğŸ¯ ä¿®å¤ç­–ç•¥

### åŸåˆ™
1. **å®‰å…¨ä¼˜å…ˆ**ï¼šå…ˆä¿® SQL æ³¨å…¥å’Œå¹¶å‘é—®é¢˜
2. **é€»è¾‘æ­£ç¡®**ï¼šä¿®å¤è¡°å‡è®¡ç®—
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šè§£å†³ç¬›å¡å°”ç§¯
4. **å¯ç»´æŠ¤æ€§**ï¼šå¼•å…¥ç‰ˆæœ¬ç®¡ç†

### ä¸é‡‡ç”¨çš„æ–¹æ¡ˆ
âŒ **å¼•å…¥ SQLAlchemy**ï¼š
- ç†ç”±ï¼šå¢åŠ  10MB+ ä¾èµ–ï¼Œè¿èƒŒ"è½»é‡çº§"åŸåˆ™
- æ›¿ä»£ï¼šæ‰‹å†™å®‰å…¨çš„å‚æ•°åŒ–æŸ¥è¯¢ + è¿æ¥æ± 

---

## ğŸ“‹ ä¿®å¤æ¸…å•

### Phase 1: å¹¶å‘å®‰å…¨ï¼ˆP0ï¼Œ2hï¼‰

#### 1.1 è¿æ¥æ±  + å†™é”

**é—®é¢˜**ï¼š
```python
def _get_connection(self):
    return sqlite3.connect(self.db_path)  # âŒ æ¯æ¬¡æ–°å»ºè¿æ¥
```

**ä¿®å¤**ï¼š
```python
import threading
from contextlib import contextmanager

class SQLiteBackend:
    def __init__(self, memory_dir: Path):
        self._conn_lock = threading.RLock()  # å¯é‡å…¥é”
        self._conn = None
        self._write_lock = threading.Lock()  # å†™æ“ä½œé”
    
    @contextmanager
    def _get_connection(self, write=False):
        """ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Œè‡ªåŠ¨åŠ é”"""
        lock = self._write_lock if write else self._conn_lock
        with lock:
            if self._conn is None:
                self._conn = sqlite3.connect(
                    self.db_path,
                    check_same_thread=False,  # å…è®¸å¤šçº¿ç¨‹
                    timeout=30.0  # 30ç§’è¶…æ—¶
                )
                self._conn.row_factory = sqlite3.Row
                self._conn.execute('PRAGMA journal_mode=WAL')
            yield self._conn
    
    def insert_memory(self, record: Dict):
        with self._get_connection(write=True) as conn:
            cursor = conn.cursor()
            # ... æ’å…¥é€»è¾‘
            conn.commit()
```

**æ•ˆæœ**ï¼š
- âœ… å•ä¾‹è¿æ¥ï¼Œé¿å…è¿æ¥æ³„æ¼
- âœ… å†™æ“ä½œäº’æ–¥ï¼Œé¿å…æ­»é”
- âœ… 30ç§’è¶…æ—¶ï¼Œé¿å…æ°¸ä¹…é˜»å¡

#### 1.2 äº‹åŠ¡éš”ç¦»çº§åˆ«

```python
def _init_db(self):
    with self._get_connection(write=True) as conn:
        conn.execute('PRAGMA journal_mode=WAL')
        conn.execute('PRAGMA synchronous=NORMAL')
        conn.execute('PRAGMA busy_timeout=30000')  # 30ç§’
        conn.execute('PRAGMA cache_size=-64000')   # 64MB ç¼“å­˜
```

---

### Phase 2: SQL æ³¨å…¥é˜²æŠ¤ï¼ˆP0ï¼Œ1hï¼‰

#### 2.1 å‚æ•°åŒ–æŸ¥è¯¢å®¡è®¡

**é—®é¢˜**ï¼š
```python
# âŒ å±é™©ï¼šåŠ¨æ€æ‹¼æ¥ placeholders
placeholders = ','.join(['?'] * len(entities))
cursor.execute(f'''
    SELECT ... WHERE me.entity IN ({placeholders})
''', entities)
```

**ä¿®å¤**ï¼š
```python
# âœ… å®‰å…¨ï¼šä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
def search_by_entities(self, entities: List[str]) -> List[Dict]:
    if not entities:
        return []
    
    # å‚æ•°åŒ–æŸ¥è¯¢ï¼Œé¿å…æ³¨å…¥
    placeholders = ','.join(['?'] * len(entities))
    query = f'''
        SELECT DISTINCT m.*
        FROM memories m
        JOIN memory_entities me ON m.id = me.memory_id
        WHERE me.entity IN ({placeholders})
        AND m.state = 0
        ORDER BY m.final_score DESC
    '''
    
    with self._get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute(query, entities)
        return [dict(row) for row in cursor.fetchall()]
```

#### 2.2 è¾“å…¥éªŒè¯

```python
def _sanitize_entity(self, entity: str) -> str:
    """æ¸…ç†å®ä½“åç§°ï¼Œé˜²æ­¢æ³¨å…¥"""
    # ç§»é™¤å±é™©å­—ç¬¦
    dangerous = [';', '--', '/*', '*/', 'DROP', 'DELETE', 'UPDATE']
    entity = entity.strip()
    for d in dangerous:
        if d in entity.upper():
            raise ValueError(f"éæ³•å®ä½“åç§°: {entity}")
    return entity[:100]  # é™åˆ¶é•¿åº¦
```

---

### Phase 3: è¡°å‡é€»è¾‘é‡æ„ï¼ˆP0ï¼Œ3hï¼‰

#### 3.1 é—®é¢˜åˆ†æ

**å½“å‰è®¾è®¡**ï¼š
```sql
final_score REAL GENERATED ALWAYS AS (score + access_boost) STORED
```

**é—®é¢˜**ï¼š
- `final_score` æ˜¯é™æ€çš„ï¼Œä¸ä¼šéšæ—¶é—´è‡ªåŠ¨è¡°å‡
- éœ€è¦æ‰‹åŠ¨è¿è¡Œ `consolidation` æ‰æ›´æ–°
- ä¸‰ä¸ªæœˆä¸ç”¨ï¼Œæ—§è®°å¿†ä¾ç„¶é«˜åˆ†

#### 3.2 è§£å†³æ–¹æ¡ˆï¼šåŠ¨æ€è®¡ç®—

**æ–¹æ¡ˆ Aï¼šæŸ¥è¯¢æ—¶è®¡ç®—ï¼ˆæ¨èï¼‰**

```python
def search_by_score(self, limit: int = 50) -> List[Dict]:
    """æ£€ç´¢æ—¶åŠ¨æ€è®¡ç®— final_score"""
    query = '''
        SELECT 
            m.*,
            -- åŠ¨æ€è®¡ç®—è¡°å‡åçš„åˆ†æ•°
            (m.score * POWER(?, julianday('now') - julianday(m.created))) 
            + m.access_boost AS dynamic_score
        FROM memories m
        WHERE m.state = 0
        ORDER BY dynamic_score DESC
        LIMIT ?
    '''
    
    decay_rate = 0.992  # æ¯å¤©è¡°å‡ 0.8%
    
    with self._get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute(query, (decay_rate, limit))
        return [dict(row) for row in cursor.fetchall()]
```

**æ–¹æ¡ˆ Bï¼šåå°å®šæ—¶æ›´æ–°ï¼ˆå¤‡é€‰ï¼‰**

```python
def apply_decay(self):
    """æ‰¹é‡åº”ç”¨è¡°å‡ï¼ˆæ¯å¤©è¿è¡Œä¸€æ¬¡ï¼‰"""
    query = '''
        UPDATE memories
        SET score = score * POWER(?, julianday('now') - julianday(updated)),
            updated = datetime('now')
        WHERE state = 0
    '''
    
    decay_rates = {
        'fact': 0.992,     # 0.8%/å¤©
        'belief': 0.93,    # 7%/å¤©
        'summary': 0.975   # 2.5%/å¤©
    }
    
    with self._get_connection(write=True) as conn:
        for mem_type, rate in decay_rates.items():
            conn.execute(query, (rate,))
        conn.commit()
```

**æ¨è**ï¼šæ–¹æ¡ˆ Aï¼ˆæŸ¥è¯¢æ—¶è®¡ç®—ï¼‰
- âœ… å®æ—¶å‡†ç¡®
- âœ… ä¸ä¾èµ–å®šæ—¶ä»»åŠ¡
- âš ï¸ æŸ¥è¯¢ç¨æ…¢ï¼ˆä½†å¯æ¥å—ï¼‰

---

### Phase 4: ç¬›å¡å°”ç§¯ä¼˜åŒ–ï¼ˆP1ï¼Œ2hï¼‰

#### 4.1 é—®é¢˜åˆ†æ

**å½“å‰æŸ¥è¯¢**ï¼š
```sql
SELECT m.*, GROUP_CONCAT(me.entity) AS entities
FROM memories m
LEFT JOIN memory_entities me ON m.id = me.memory_id
GROUP BY m.id
```

**é—®é¢˜**ï¼š
- ä¸€ä¸ªè®°å¿†å…³è” 5 ä¸ªå®ä½“ â†’ ä¸­é—´è¡¨ 5 è¡Œ
- 100 æ¡è®°å¿† Ã— å¹³å‡ 3 å®ä½“ = 300 è¡Œä¸­é—´è¡¨

#### 4.2 ä¼˜åŒ–æ–¹æ¡ˆ

**æ–¹æ¡ˆ Aï¼šå­æŸ¥è¯¢ï¼ˆæ¨èï¼‰**

```python
def get_all_memories(self, state: int = 0) -> List[Dict]:
    """ä¼˜åŒ–çš„å…¨é‡æŸ¥è¯¢"""
    query = '''
        SELECT 
            m.*,
            (SELECT GROUP_CONCAT(entity) 
             FROM memory_entities 
             WHERE memory_id = m.id) AS entities
        FROM memories m
        WHERE m.state = ?
        ORDER BY m.final_score DESC
    '''
    
    with self._get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute(query, (state,))
        results = []
        for row in cursor.fetchall():
            record = dict(row)
            record['entities'] = record['entities'].split(',') if record['entities'] else []
            results.append(record)
        return results
```

**æ–¹æ¡ˆ Bï¼šä¸¤æ¬¡æŸ¥è¯¢ï¼ˆå¤§æ•°æ®é‡ï¼‰**

```python
def get_all_memories_optimized(self, state: int = 0) -> List[Dict]:
    """ä¸¤æ¬¡æŸ¥è¯¢ï¼Œé¿å…ç¬›å¡å°”ç§¯"""
    with self._get_connection() as conn:
        cursor = conn.cursor()
        
        # ç¬¬ä¸€æ¬¡ï¼šæŸ¥è¯¢è®°å¿†
        cursor.execute('SELECT * FROM memories WHERE state = ?', (state,))
        memories = [dict(row) for row in cursor.fetchall()]
        
        # ç¬¬äºŒæ¬¡ï¼šæ‰¹é‡æŸ¥è¯¢å®ä½“
        memory_ids = [m['id'] for m in memories]
        placeholders = ','.join(['?'] * len(memory_ids))
        cursor.execute(f'''
            SELECT memory_id, GROUP_CONCAT(entity) AS entities
            FROM memory_entities
            WHERE memory_id IN ({placeholders})
            GROUP BY memory_id
        ''', memory_ids)
        
        # åˆå¹¶ç»“æœ
        entity_map = {row['memory_id']: row['entities'].split(',') 
                      for row in cursor.fetchall()}
        
        for m in memories:
            m['entities'] = entity_map.get(m['id'], [])
        
        return memories
```

---

### Phase 5: ç‰ˆæœ¬ç®¡ç†ï¼ˆP2ï¼Œ1hï¼‰

#### 5.1 Schema ç‰ˆæœ¬è¡¨

```sql
CREATE TABLE IF NOT EXISTS schema_version (
    version INTEGER PRIMARY KEY,
    applied_at TEXT NOT NULL,
    description TEXT
);

INSERT INTO schema_version (version, applied_at, description)
VALUES (1, datetime('now'), 'Initial schema');
```

#### 5.2 è¿ç§»æ¡†æ¶

```python
class Migration:
    """æ•°æ®åº“è¿ç§»ç®¡ç†"""
    
    MIGRATIONS = {
        1: {
            'description': 'Initial schema',
            'up': SCHEMA_SQL,
            'down': 'DROP TABLE IF EXISTS memories; ...'
        },
        2: {
            'description': 'Add dynamic_score support',
            'up': '''
                ALTER TABLE memories ADD COLUMN decay_applied_at TEXT;
            ''',
            'down': '''
                -- SQLite ä¸æ”¯æŒ DROP COLUMNï¼Œéœ€è¦é‡å»ºè¡¨
            '''
        }
    }
    
    def get_current_version(self, conn) -> int:
        """è·å–å½“å‰ç‰ˆæœ¬"""
        try:
            cursor = conn.cursor()
            cursor.execute('SELECT MAX(version) FROM schema_version')
            result = cursor.fetchone()
            return result[0] if result[0] else 0
        except sqlite3.OperationalError:
            return 0
    
    def migrate(self, target_version: int = None):
        """æ‰§è¡Œè¿ç§»"""
        with self._get_connection(write=True) as conn:
            current = self.get_current_version(conn)
            target = target_version or max(self.MIGRATIONS.keys())
            
            for version in range(current + 1, target + 1):
                migration = self.MIGRATIONS[version]
                print(f"åº”ç”¨è¿ç§» v{version}: {migration['description']}")
                conn.executescript(migration['up'])
                conn.execute('''
                    INSERT INTO schema_version (version, applied_at, description)
                    VALUES (?, datetime('now'), ?)
                ''', (version, migration['description']))
                conn.commit()
```

---

## ğŸ“Š ä¿®å¤ä¼˜å…ˆçº§

| Phase | ä»»åŠ¡ | æ—¶é—´ | ä¼˜å…ˆçº§ | ä¾èµ– |
|-------|------|------|--------|------|
| 1 | å¹¶å‘å®‰å…¨ | 2h | P0 | - |
| 2 | SQL æ³¨å…¥é˜²æŠ¤ | 1h | P0 | - |
| 3 | è¡°å‡é€»è¾‘é‡æ„ | 3h | P0 | Phase 1 |
| 4 | ç¬›å¡å°”ç§¯ä¼˜åŒ– | 2h | P1 | Phase 1 |
| 5 | ç‰ˆæœ¬ç®¡ç† | 1h | P2 | - |

**æ€»è®¡**ï¼š9 å°æ—¶

---

## ğŸ§ª æµ‹è¯•è®¡åˆ’

### 1. å¹¶å‘æµ‹è¯•

```python
import threading

def test_concurrent_writes():
    """æµ‹è¯•å¹¶å‘å†™å…¥"""
    backend = SQLiteBackend(memory_dir)
    
    def write_memory(i):
        backend.insert_memory({
            'id': f'test_{i}',
            'content': f'Test memory {i}',
            'entities': ['test']
        })
    
    threads = [threading.Thread(target=write_memory, args=(i,)) 
               for i in range(100)]
    
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    
    # éªŒè¯ï¼š100 æ¡è®°å¿†å…¨éƒ¨å†™å…¥
    assert len(backend.get_all_memories()) == 100
```

### 2. SQL æ³¨å…¥æµ‹è¯•

```python
def test_sql_injection():
    """æµ‹è¯• SQL æ³¨å…¥é˜²æŠ¤"""
    backend = SQLiteBackend(memory_dir)
    
    # å°è¯•æ³¨å…¥
    malicious_entity = "'; DROP TABLE memories; --"
    
    try:
        backend.search_by_entities([malicious_entity])
        assert False, "åº”è¯¥æŠ›å‡ºå¼‚å¸¸"
    except ValueError:
        pass  # é¢„æœŸè¡Œä¸º
    
    # éªŒè¯ï¼šæ•°æ®åº“æœªè¢«ç ´å
    assert backend.get_all_memories() is not None
```

### 3. è¡°å‡æµ‹è¯•

```python
def test_decay_logic():
    """æµ‹è¯•è¡°å‡é€»è¾‘"""
    backend = SQLiteBackend(memory_dir)
    
    # æ’å…¥æ—§è®°å¿†ï¼ˆ90 å¤©å‰ï¼‰
    old_memory = {
        'id': 'old_001',
        'content': 'Old memory',
        'score': 1.0,
        'created': (datetime.now() - timedelta(days=90)).isoformat()
    }
    backend.insert_memory(old_memory)
    
    # æ’å…¥æ–°è®°å¿†
    new_memory = {
        'id': 'new_001',
        'content': 'New memory',
        'score': 1.0,
        'created': datetime.now().isoformat()
    }
    backend.insert_memory(new_memory)
    
    # æ£€ç´¢ï¼šæ–°è®°å¿†åº”è¯¥æ’åœ¨å‰é¢
    results = backend.search_by_score(limit=10)
    assert results[0]['id'] == 'new_001'
```

---

## ğŸ¯ æˆåŠŸæŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡ | éªŒè¯æ–¹æ³• |
|------|------|---------|
| å¹¶å‘å®‰å…¨ | 100 çº¿ç¨‹æ— æ­»é” | å¹¶å‘æµ‹è¯• |
| SQL æ³¨å…¥é˜²æŠ¤ | 100% æ‹¦æˆª | æ³¨å…¥æµ‹è¯• |
| è¡°å‡å‡†ç¡®æ€§ | è¯¯å·® < 5% | è¡°å‡æµ‹è¯• |
| æŸ¥è¯¢æ€§èƒ½ | < 50ms (1000 æ¡) | æ€§èƒ½æµ‹è¯• |
| ç‰ˆæœ¬è¿ç§» | æ— æ•°æ®ä¸¢å¤± | è¿ç§»æµ‹è¯• |

---

## ğŸ“ å®æ–½æ­¥éª¤

1. **åˆ›å»ºåˆ†æ”¯**ï¼š`git checkout -b fix/v1.2.5-critical-fixes`
2. **é€ä¸ªä¿®å¤**ï¼šæŒ‰ Phase 1-5 é¡ºåº
3. **å•å…ƒæµ‹è¯•**ï¼šæ¯ä¸ª Phase å®Œæˆåæµ‹è¯•
4. **é›†æˆæµ‹è¯•**ï¼šå…¨éƒ¨å®Œæˆåå‹æµ‹
5. **æ–‡æ¡£æ›´æ–°**ï¼šæ›´æ–° SKILL.md å’Œä½¿ç”¨æŒ‡å—
6. **å‘å¸ƒ**ï¼šåˆå¹¶åˆ° mainï¼Œæ‰“ tag v1.2.5

---

## ğŸ™ è‡´è°¢

æ„Ÿè°¢ Crabby çš„æ·±åº¦å®¡è®¡ï¼ŒæŒ‡å‡ºäº†è¿™äº›è‡´å‘½ç¼ºé™·ã€‚è¿™ä»½æŠ¥å‘Šè®©æˆ‘ä»¬æ„è¯†åˆ°ï¼š

> **æ€§èƒ½ä¼˜åŒ–ä¸èƒ½ä»¥ç‰ºç‰²å®‰å…¨å’Œæ­£ç¡®æ€§ä¸ºä»£ä»·ã€‚**

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2026-02-14 04:15 UTC  
**ä½œè€…**: [åŠ©æ‰‹]  
**é¢„è®¡å®Œæˆ**: 2026-02-14 13:00 UTC
