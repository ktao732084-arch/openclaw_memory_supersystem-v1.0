# Memory System v1.3.0 å¼€å‘è®¡åˆ’
## åŸºäºè¯„æµ‹é›†è°ƒç ”çš„ç³»ç»Ÿæ€§å‡çº§æ–¹æ¡ˆ

---

## ğŸ“Š è°ƒç ”æ ¸å¿ƒå‘ç°

### å››å¤§è¯„æµ‹é›†å¯¹æ¯”

| è¯„æµ‹é›† | æ ¸å¿ƒè€ƒå¯Ÿ | SOTA åˆ†æ•° | æˆ‘ä»¬çš„æœ€å¤§å·®è· |
|--------|---------|-----------|---------------|
| **LoCoMo** | é•¿ä¼šè¯ä¸€è‡´æ€§ | 93.05% | è¯æ®è¿½è¸ª + å¤šæ¨¡æ€ç´¢å¼• |
| **LongMemEval** | ç™¾ä¸‡çº§æ‰©å±•æ€§ | 83% | æ—¶åºæ¨ç† + äº‹å®æ¼”å˜è¿½è¸ª |
| **HaluMem** | æ“ä½œçº§å¹»è§‰æ£€æµ‹ | 86.35% | å†²çªæ¶ˆè§£ + è™šå‡è®°å¿†è¿‡æ»¤ |
| **PersonaMem v2** | éšå¼ç”»åƒå­¦ä¹  | 55% | éšå¼åå¥½æå– + å½’å±è¯†åˆ« |

### å½“å‰èƒ½åŠ› vs è¯„æµ‹è¦æ±‚

| èƒ½åŠ›ç»´åº¦ | å½“å‰çŠ¶æ€ | è¯„æµ‹è¦æ±‚ | ä¼˜å…ˆçº§ |
|---------|---------|---------|--------|
| å†²çªå¤„ç† | âŒ ç®€å•è¦†å†™ | âœ… ç½®ä¿¡åº¦ + æ—¶åºæ¶ˆè§£ | ğŸ”´ P0 |
| è™šå‡è®°å¿†è¿‡æ»¤ | âŒ æ— è¿‡æ»¤ | âœ… FMR > 85% | ğŸ”´ P0 |
| æ—¶åºæ¨ç† | âš ï¸ åŸºç¡€æ”¯æŒ | âœ… æ—¶é—´è·³è·ƒ + æ¼”å˜è¿½è¸ª | ğŸŸ¡ P1 |
| éšå¼ç”»åƒ | âŒ ä»…å…³é”®è¯ | âœ… è¡Œä¸ºæ¨¡å¼æ¨ç† | ğŸŸ  P2 |
| è¯æ®è¿½è¸ª | âŒ æ— æº¯æº | âœ… è¿”å›æ¥æº ID | ğŸŸ¡ P1 |
| ç™¾ä¸‡çº§ç´¢å¼• | âš ï¸ SQLite æœªå‹æµ‹ | âœ… å‘é‡-å›¾æ··åˆ | ğŸŸ¡ P1 |

---

## ğŸ¯ ä¸‰é˜¶æ®µæ¼”è¿›è·¯çº¿

### Phase 1: åŸºç¡€èƒ½åŠ›è¡¥é½ï¼ˆå¿…é¡»ï¼‰
**ç›®æ ‡**: é€šè¿‡ HaluMem åŸºæœ¬æµ‹è¯•ï¼Œè§£å†³å¹»è§‰ç´¯ç§¯é—®é¢˜

**é¢„è®¡å·¥ä½œé‡**: 120 å°æ—¶ â†’ **ç®€åŒ–ä¸º 40-60 å°æ—¶**

#### 1.1 Memory Operatorï¼ˆè®°å¿†æ“ä½œå†³ç­–å¼•æ“ï¼‰

**å‚è€ƒ**: Mem0 çš„ ADD/UPDATE/DELETE/NOOP æ¶æ„

**å®ç°**:
```python
class MemoryOperator:
    """è®°å¿†æ“ä½œå†³ç­–å¼•æ“"""
    
    OPERATIONS = ['ADD', 'UPDATE', 'DELETE', 'NOOP']
    
    def decide_operation(self, new_memory: Dict, existing_memories: List[Dict]) -> str:
        """
        å†³å®šå¯¹æ–°è®°å¿†æ‰§è¡Œä»€ä¹ˆæ“ä½œ
        
        Args:
            new_memory: æ–°æå–çš„è®°å¿†
            existing_memories: ç›¸å…³çš„å·²æœ‰è®°å¿†
        
        Returns:
            æ“ä½œç±»å‹: ADD/UPDATE/DELETE/NOOP
        """
        # 1. æ£€æŸ¥æ˜¯å¦ä¸ºå™ªå£°ï¼ˆè™šå‡è®°å¿†è¿‡æ»¤ï¼‰
        if self._is_noise(new_memory):
            return 'NOOP'
        
        # 2. æ£€æŸ¥æ˜¯å¦å­˜åœ¨å†²çª
        conflicts = self._find_conflicts(new_memory, existing_memories)
        
        if conflicts:
            # 3. åŸºäºæ—¶é—´æˆ³å’Œç½®ä¿¡åº¦å†³å®š
            if self._should_update(new_memory, conflicts):
                return 'UPDATE'
            elif self._should_delete(new_memory, conflicts):
                return 'DELETE'
            else:
                return 'NOOP'
        else:
            return 'ADD'
    
    def _is_noise(self, memory: Dict) -> bool:
        """è™šå‡è®°å¿†è¿‡æ»¤å™¨"""
        noise_patterns = [
            'æ•°å­¦è®¡ç®—', 'çç¢ QA', 'å¤©æ°”æŸ¥è¯¢', 
            'æ—¶é—´æŸ¥è¯¢', 'å•ä½æ¢ç®—', 'ä¸´æ—¶æŒ‡ä»¤'
        ]
        # ä½¿ç”¨ LLM æˆ–è§„åˆ™åˆ¤æ–­
        return any(pattern in memory['content'] for pattern in noise_patterns)
    
    def _find_conflicts(self, new: Dict, existing: List[Dict]) -> List[Dict]:
        """å†²çªæ£€æµ‹"""
        conflicts = []
        for old in existing:
            # æ£€æŸ¥å®ä½“é‡å 
            if set(new['entities']) & set(old['entities']):
                # æ£€æŸ¥è¯­ä¹‰å†²çª
                if self._is_semantic_conflict(new['content'], old['content']):
                    conflicts.append(old)
        return conflicts
    
    def _should_update(self, new: Dict, conflicts: List[Dict]) -> bool:
        """åŸºäºæ—¶é—´æˆ³å’Œç½®ä¿¡åº¦å†³å®šæ˜¯å¦æ›´æ–°"""
        for old in conflicts:
            # æ–°è®°å¿†æ›´æ–° + ç½®ä¿¡åº¦æ›´é«˜ â†’ UPDATE
            if new['timestamp'] > old['timestamp'] and new['confidence'] >= old['confidence']:
                return True
        return False
```

**å·¥ä½œé‡**: 15-20 å°æ—¶

#### 1.2 å¢å¼º Memory Point ç»“æ„

**å½“å‰ç»“æ„**:
```json
{
  "id": "f_001",
  "content": "ç”¨æˆ·å¯¹èŠ±ç”Ÿè¿‡æ•",
  "type": "fact",
  "importance": 1.0,
  "score": 1.0,
  "entities": ["ç”¨æˆ·", "èŠ±ç”Ÿ"]
}
```

**æ–°ç»“æ„**:
```json
{
  "id": "f_001",
  "content": "ç”¨æˆ·å¯¹èŠ±ç”Ÿè¿‡æ•",
  "type": "fact",
  "importance": 1.0,
  "score": 1.0,
  "confidence": 1.0,
  
  // æ–°å¢å­—æ®µ
  "timestamp": "2026-02-14T10:30:00Z",
  "session_id": "session_123",
  "source_quote": "æˆ‘å¯¹èŠ±ç”Ÿè¿‡æ•ï¼Œåƒäº†ä¼šæ­»",
  "source_turn": 15,
  "ownership": "user",  // user/assistant/third_party
  
  "entities": ["ç”¨æˆ·", "èŠ±ç”Ÿ"],
  
  // å†²çªç®¡ç†
  "supersedes": ["f_000"],  // å–ä»£çš„æ—§è®°å¿† ID
  "superseded_by": null,
  "conflict_resolved_at": null
}
```

**å·¥ä½œé‡**: 5-8 å°æ—¶

#### 1.3 æ˜¾å¼å†²çªæ¶ˆè§£åè®®

**å®ç°**:
```python
class ConflictResolver:
    """å†²çªæ¶ˆè§£å™¨"""
    
    def resolve(self, new: Dict, old: Dict) -> Dict:
        """
        è§£å†³ä¸¤æ¡è®°å¿†çš„å†²çª
        
        ç­–ç•¥:
        1. æ—¶é—´ä¼˜å…ˆ: æ–°è®°å¿† > æ—§è®°å¿†
        2. ç½®ä¿¡åº¦ä¼˜å…ˆ: é«˜ç½®ä¿¡åº¦ > ä½ç½®ä¿¡åº¦
        3. æ¥æºä¼˜å…ˆ: ç”¨æˆ·é™ˆè¿° > æ¨æ–­
        
        Returns:
            è§£å†³æ–¹æ¡ˆ: {'action': 'UPDATE', 'winner': new, 'loser': old}
        """
        # æ—¶é—´æˆ³æ¯”è¾ƒ
        if new['timestamp'] > old['timestamp']:
            time_score = 1
        else:
            time_score = -1
        
        # ç½®ä¿¡åº¦æ¯”è¾ƒ
        conf_score = new['confidence'] - old['confidence']
        
        # æ¥æºä¼˜å…ˆçº§
        source_priority = {'user': 3, 'assistant': 2, 'third_party': 1}
        source_score = source_priority[new['ownership']] - source_priority[old['ownership']]
        
        # ç»¼åˆè¯„åˆ†
        total_score = time_score * 0.5 + conf_score * 0.3 + source_score * 0.2
        
        if total_score > 0:
            return {
                'action': 'UPDATE',
                'winner': new,
                'loser': old,
                'reason': f'æ—¶é—´={time_score}, ç½®ä¿¡åº¦={conf_score:.2f}, æ¥æº={source_score}'
            }
        else:
            return {
                'action': 'KEEP',
                'winner': old,
                'loser': new,
                'reason': 'æ—§è®°å¿†æ›´å¯é '
            }
```

**å·¥ä½œé‡**: 10-15 å°æ—¶

#### 1.4 è™šå‡è®°å¿†è¿‡æ»¤å™¨ï¼ˆFMRï¼‰

**ç›®æ ‡**: FMR (False Memory Resistance) > 85%

**å®ç°**:
```python
class NoiseFilter:
    """è™šå‡è®°å¿†è¿‡æ»¤å™¨"""
    
    # å™ªå£°æ¨¡å¼ï¼ˆè§„åˆ™ï¼‰
    NOISE_PATTERNS = [
        r'^\d+[\+\-\*/]\d+',  # æ•°å­¦è®¡ç®—
        r'^what is \d+',      # çç¢é—®ç­”
        r'^ä»Šå¤©å¤©æ°”',          # å¤©æ°”æŸ¥è¯¢
        r'^ç°åœ¨å‡ ç‚¹',          # æ—¶é—´æŸ¥è¯¢
        r'^å¸®æˆ‘æœç´¢',          # ä¸´æ—¶æŒ‡ä»¤
    ]
    
    # å™ªå£°å…³é”®è¯
    NOISE_KEYWORDS = [
        'å•ä½æ¢ç®—', 'ç¿»è¯‘', 'å®šæ—¶å™¨', 'é—¹é’Ÿ',
        'è®¡ç®—å™¨', 'æœç´¢', 'æŸ¥è¯¢', 'å¸®æˆ‘æ‰¾'
    ]
    
    def is_noise(self, content: str, context: Dict) -> bool:
        """
        åˆ¤æ–­æ˜¯å¦ä¸ºå™ªå£°
        
        Args:
            content: è®°å¿†å†…å®¹
            context: ä¸Šä¸‹æ–‡ï¼ˆå¯¹è¯è½®æ¬¡ã€ç±»å‹ç­‰ï¼‰
        
        Returns:
            æ˜¯å¦ä¸ºå™ªå£°
        """
        # è§„åˆ™ 1: æ­£åˆ™åŒ¹é…
        for pattern in self.NOISE_PATTERNS:
            if re.match(pattern, content):
                return True
        
        # è§„åˆ™ 2: å…³é”®è¯åŒ¹é…
        if any(kw in content for kw in self.NOISE_KEYWORDS):
            return True
        
        # è§„åˆ™ 3: é•¿åº¦è¿‡æ»¤ï¼ˆå¤ªçŸ­çš„é€šå¸¸æ˜¯å™ªå£°ï¼‰
        if len(content) < 10:
            return True
        
        # è§„åˆ™ 4: é‡è¦æ€§è¿‡æ»¤
        if context.get('importance', 0) < 0.3:
            return True
        
        return False
    
    def filter_batch(self, memories: List[Dict]) -> List[Dict]:
        """æ‰¹é‡è¿‡æ»¤"""
        return [m for m in memories if not self.is_noise(m['content'], m)]
```

**å·¥ä½œé‡**: 8-10 å°æ—¶

---

### Phase 2: æ€§èƒ½ä¸æ—¶åºä¼˜åŒ–ï¼ˆé‡è¦ï¼‰
**ç›®æ ‡**: å¯¹é½ LongMemEval çš„ç™¾ä¸‡çº§ Token è¦æ±‚

**é¢„è®¡å·¥ä½œé‡**: 200 å°æ—¶ â†’ **ç®€åŒ–ä¸º 60-80 å°æ—¶**

#### 2.1 æ—¶åºå¢å¼ºæŸ¥è¯¢

**å®ç°**:
```python
class TemporalQueryEngine:
    """æ—¶åºæŸ¥è¯¢å¼•æ“"""
    
    def rewrite_temporal_query(self, query: str, current_time: datetime) -> Dict:
        """
        é‡å†™æ—¶åºæŸ¥è¯¢
        
        Examples:
            "ä»–ä¸Šæ¬¡è¯´çš„è¯" â†’ {"time_range": ["2026-02-13", "2026-02-14"]}
            "ä¸‰ä¸ªæœˆå‰" â†’ {"time_range": ["2025-11-14", "2025-11-14"]}
        """
        temporal_patterns = {
            r'ä¸Šæ¬¡': lambda: current_time - timedelta(days=1),
            r'æ˜¨å¤©': lambda: current_time - timedelta(days=1),
            r'ä¸Šå‘¨': lambda: current_time - timedelta(weeks=1),
            r'ä¸Šä¸ªæœˆ': lambda: current_time - timedelta(days=30),
            r'(\d+)ä¸ªæœˆå‰': lambda m: current_time - timedelta(days=30*int(m.group(1))),
        }
        
        for pattern, time_func in temporal_patterns.items():
            match = re.search(pattern, query)
            if match:
                target_time = time_func() if callable(time_func) else time_func(match)
                return {
                    'time_range': [
                        target_time.isoformat(),
                        (target_time + timedelta(days=1)).isoformat()
                    ]
                }
        
        return {}
    
    def apply_time_decay(self, memories: List[Dict], current_time: datetime) -> List[Dict]:
        """åº”ç”¨æ—¶é—´è¡°å‡"""
        for m in memories:
            created = datetime.fromisoformat(m['created'])
            days_elapsed = (current_time - created).days
            
            # è¡°å‡å‡½æ•°: Î³ = e^(-Î»Î”t)
            lambda_decay = 0.01  # è¡°å‡ç‡
            decay_factor = math.exp(-lambda_decay * days_elapsed)
            
            m['time_decayed_score'] = m['score'] * decay_factor
        
        return memories
```

**å·¥ä½œé‡**: 15-20 å°æ—¶

#### 2.2 äº‹å®æ¼”å˜è¿½è¸ª

**å®ç°**:
```python
class FactEvolutionTracker:
    """äº‹å®æ¼”å˜è¿½è¸ªå™¨"""
    
    def track_evolution(self, entity: str, attribute: str) -> List[Dict]:
        """
        è¿½è¸ªå®ä½“å±æ€§çš„æ¼”å˜å†å²
        
        Example:
            entity="ç”¨æˆ·", attribute="location"
            â†’ [
                {"value": "åŒ—äº¬", "valid_from": "2025-01-01", "valid_to": "2026-01-01"},
                {"value": "ä¸Šæµ·", "valid_from": "2026-01-01", "valid_to": None}
            ]
        """
        # æŸ¥è¯¢æ‰€æœ‰ç›¸å…³è®°å¿†
        memories = self.backend.search_by_entities([entity])
        
        # æå–å±æ€§å˜åŒ–
        evolution = []
        for m in sorted(memories, key=lambda x: x['timestamp']):
            if attribute in m['content']:
                value = self._extract_value(m['content'], attribute)
                evolution.append({
                    'value': value,
                    'valid_from': m['timestamp'],
                    'valid_to': None,
                    'memory_id': m['id']
                })
                
                # æ›´æ–°ä¸Šä¸€æ¡çš„ valid_to
                if len(evolution) > 1:
                    evolution[-2]['valid_to'] = m['timestamp']
        
        return evolution
    
    def get_current_value(self, entity: str, attribute: str, at_time: datetime = None) -> str:
        """è·å–æŒ‡å®šæ—¶é—´ç‚¹çš„å±æ€§å€¼"""
        evolution = self.track_evolution(entity, attribute)
        
        at_time = at_time or datetime.now()
        
        for item in reversed(evolution):
            valid_from = datetime.fromisoformat(item['valid_from'])
            valid_to = datetime.fromisoformat(item['valid_to']) if item['valid_to'] else datetime.now()
            
            if valid_from <= at_time <= valid_to:
                return item['value']
        
        return None
```

**å·¥ä½œé‡**: 20-25 å°æ—¶

#### 2.3 è¯æ®è¿½è¸ªï¼ˆEvidence Trackingï¼‰

**å®ç°**:
```python
class EvidenceTracker:
    """è¯æ®è¿½è¸ªå™¨"""
    
    def add_evidence(self, memory: Dict, source_turn: int, source_quote: str):
        """æ·»åŠ è¯æ®"""
        memory['evidence'] = {
            'turn': source_turn,
            'quote': source_quote,
            'session_id': memory['session_id'],
            'timestamp': memory['timestamp']
        }
    
    def get_evidence_chain(self, memory_id: str) -> List[Dict]:
        """è·å–è¯æ®é“¾"""
        memory = self.backend.get_memory(memory_id)
        
        chain = [memory['evidence']]
        
        # å¦‚æœæ˜¯æ›´æ–°ï¼Œè¿½æº¯åŸå§‹è¯æ®
        if memory.get('supersedes'):
            for old_id in memory['supersedes']:
                old_memory = self.backend.get_memory(old_id)
                if old_memory and old_memory.get('evidence'):
                    chain.append(old_memory['evidence'])
        
        return chain
    
    def format_for_locomo(self, memory: Dict) -> Dict:
        """æ ¼å¼åŒ–ä¸º LoCoMo è¦æ±‚çš„è¾“å‡º"""
        return {
            'answer': memory['content'],
            'evidence_ids': [e['turn'] for e in self.get_evidence_chain(memory['id'])],
            'confidence': memory['confidence']
        }
```

**å·¥ä½œé‡**: 10-15 å°æ—¶

---

### Phase 3: é«˜é˜¶æ™ºèƒ½æ¼”è¿›ï¼ˆå¯é€‰ï¼‰
**ç›®æ ‡**: PersonaMem v2 çªç ´

**é¢„è®¡å·¥ä½œé‡**: 350 å°æ—¶ â†’ **æš‚ç¼“ï¼Œç­‰ Phase 1-2 å®Œæˆåè¯„ä¼°**

---

## ğŸ“‹ ç«‹å³æ‰§è¡Œè®¡åˆ’ï¼ˆv1.3.0ï¼‰

### ä¼˜å…ˆçº§æ’åº

| ä»»åŠ¡ | Phase | å·¥ä½œé‡ | ä¼˜å…ˆçº§ | ä¾èµ– |
|------|-------|--------|--------|------|
| Memory Operator | 1.1 | 15-20h | ğŸ”´ P0 | - |
| å¢å¼º MP ç»“æ„ | 1.2 | 5-8h | ğŸ”´ P0 | - |
| å†²çªæ¶ˆè§£åè®® | 1.3 | 10-15h | ğŸ”´ P0 | 1.1, 1.2 |
| è™šå‡è®°å¿†è¿‡æ»¤ | 1.4 | 8-10h | ğŸ”´ P0 | 1.1 |
| æ—¶åºæŸ¥è¯¢å¼•æ“ | 2.1 | 15-20h | ğŸŸ¡ P1 | 1.2 |
| äº‹å®æ¼”å˜è¿½è¸ª | 2.2 | 20-25h | ğŸŸ¡ P1 | 1.2, 1.3 |
| è¯æ®è¿½è¸ª | 2.3 | 10-15h | ğŸŸ¡ P1 | 1.2 |

### æ€»å·¥ä½œé‡ä¼°ç®—

- **Phase 1 (P0)**: 38-53 å°æ—¶
- **Phase 2 (P1)**: 45-60 å°æ—¶
- **æ€»è®¡**: 83-113 å°æ—¶

---

## ğŸ¯ æˆåŠŸæŒ‡æ ‡

### Phase 1 å®Œæˆæ ‡å‡†

| æŒ‡æ ‡ | ç›®æ ‡ | éªŒè¯æ–¹æ³• |
|------|------|---------|
| è™šå‡è®°å¿†è¿‡æ»¤ç‡ (FMR) | > 85% | HaluMem æµ‹è¯•é›† |
| å†²çªæ¶ˆè§£å‡†ç¡®ç‡ | > 90% | æ‰‹åŠ¨æ„é€ å†²çªåœºæ™¯ |
| æ“ä½œå†³ç­–å‡†ç¡®ç‡ | > 80% | ADD/UPDATE/DELETE å†³ç­–æµ‹è¯• |

### Phase 2 å®Œæˆæ ‡å‡†

| æŒ‡æ ‡ | ç›®æ ‡ | éªŒè¯æ–¹æ³• |
|------|------|---------|
| æ—¶åºæŸ¥è¯¢å‡†ç¡®ç‡ | > 75% | LongMemEval æ—¶åºå­é›† |
| äº‹å®æ¼”å˜è¿½è¸ªå‡†ç¡®ç‡ | > 80% | æ‰‹åŠ¨æ„é€ æ¼”å˜åœºæ™¯ |
| è¯æ®æº¯æºå®Œæ•´æ€§ | 100% | LoCoMo è¯æ®è¿”å›æµ‹è¯• |

---

## ğŸš€ ä¸‹ä¸€æ­¥è¡ŒåŠ¨

1. **ç«‹å³å¼€å§‹ Phase 1.1**: Memory Operator å®ç°
2. **å¹¶è¡Œè¿›è¡Œ Phase 1.2**: å¢å¼º MP ç»“æ„ï¼ˆä¿®æ”¹ Schemaï¼‰
3. **å®Œæˆ Phase 1 å**: è¿è¡Œ HaluMem æµ‹è¯•ï¼ŒéªŒè¯æ•ˆæœ
4. **æ ¹æ®æµ‹è¯•ç»“æœ**: å†³å®šæ˜¯å¦è¿›å…¥ Phase 2

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2026-02-14 04:50 UTC  
**ä½œè€…**: [åŠ©æ‰‹]  
**åŸºäº**: è¯„æµ‹é›†æ·±åº¦è°ƒç ”æŠ¥å‘Š
