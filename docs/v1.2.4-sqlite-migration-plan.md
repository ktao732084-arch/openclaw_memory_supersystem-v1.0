# Memory System v1.2.4 - SQLite è¿ç§»æ–¹æ¡ˆ

## èƒŒæ™¯

**Crabby çš„æ‰¹è¯„**: "åˆ«åœ¨è…çƒ‚çš„æœ¨å¤´ä¸Šé›•èŠ±ã€‚ç›´æ¥ä¸Š SQLiteï¼Œä¸€æ­¥åˆ°ä½ã€‚"

**æ ¸å¿ƒé—®é¢˜**: JSONL æ ¼å¼æœ¬è´¨æ˜¯ Append-onlyï¼Œåœ¨ä¸Šé¢ç©éšæœºä¿®æ”¹æ˜¯æ¶æ„é”™è¯¯ã€‚

---

## ğŸ¯ è¿ç§»ç›®æ ‡

### æ€§èƒ½ç›®æ ‡

| æ“ä½œ | JSONL (å½“å‰) | SQLite (ç›®æ ‡) | æå‡ |
|------|-------------|--------------|------|
| å•æ¬¡è®¿é—®æ›´æ–° | O(N) å…¨æ–‡ä»¶è¯»å†™ | O(1) å•è¡Œæ›´æ–° | 100x+ |
| æŸ¥è¯¢ 10 æ¡è®°å¿† | O(N) å…¨æ–‡ä»¶æ‰«æ | O(log N) ç´¢å¼•æŸ¥è¯¢ | 10x+ |
| æ’å…¥æ–°è®°å¿† | O(1) è¿½åŠ  | O(1) æ’å…¥ | æŒå¹³ |

### åŠŸèƒ½ç›®æ ‡

- âœ… ä¿æŒæ‰€æœ‰ç°æœ‰åŠŸèƒ½
- âœ… å‘åå…¼å®¹ï¼ˆæä¾› JSONL å¯¼å‡ºï¼‰
- âœ… é›¶é…ç½®ï¼ˆSQLite æ˜¯ Python æ ‡å‡†åº“ï¼‰
- âœ… å•æ–‡ä»¶å­˜å‚¨ï¼ˆä¾¿äºå¤‡ä»½å’Œè¿ç§»ï¼‰

---

## ğŸ“Š æ•°æ®åº“è®¾è®¡

### æ ¸å¿ƒè¡¨ç»“æ„

```sql
-- è®°å¿†ä¸»è¡¨
CREATE TABLE memories (
    id TEXT PRIMARY KEY,
    type TEXT NOT NULL,  -- 'fact', 'belief', 'summary'
    content TEXT NOT NULL,
    importance REAL DEFAULT 0.5,
    score REAL DEFAULT 1.0,
    
    -- æ—¶é—´å­—æ®µ
    created_at TEXT NOT NULL,
    updated_at TEXT,
    last_accessed TEXT,
    expires_at TEXT,
    
    -- è®¿é—®ç»Ÿè®¡
    access_count INTEGER DEFAULT 0,
    retrieval_count INTEGER DEFAULT 0,
    used_in_response_count INTEGER DEFAULT 0,
    user_mentioned_count INTEGER DEFAULT 0,
    access_boost REAL DEFAULT 0.0,
    
    -- å†²çªç®¡ç†
    conflict_downgraded INTEGER DEFAULT 0,  -- 0/1 å¸ƒå°”å€¼
    downgrade_reason TEXT,
    downgrade_at TEXT,
    superseded INTEGER DEFAULT 0,
    superseded_by TEXT,
    
    -- å…ƒæ•°æ®ï¼ˆJSON å­—æ®µï¼‰
    metadata TEXT,  -- å­˜å‚¨å…¶ä»–å­—æ®µçš„ JSON
    
    -- ç´¢å¼•å­—æ®µ
    is_permanent INTEGER DEFAULT 1,
    status TEXT DEFAULT 'active'  -- 'active', 'archived', 'expired'
);

-- å®ä½“å…³è”è¡¨
CREATE TABLE memory_entities (
    memory_id TEXT NOT NULL,
    entity TEXT NOT NULL,
    entity_type TEXT,  -- 'person', 'place', 'project', etc.
    PRIMARY KEY (memory_id, entity),
    FOREIGN KEY (memory_id) REFERENCES memories(id) ON DELETE CASCADE
);

-- å…³é”®è¯ç´¢å¼•è¡¨
CREATE TABLE memory_keywords (
    memory_id TEXT NOT NULL,
    keyword TEXT NOT NULL,
    weight REAL DEFAULT 1.0,
    PRIMARY KEY (memory_id, keyword),
    FOREIGN KEY (memory_id) REFERENCES memories(id) ON DELETE CASCADE
);

-- è®¿é—®æ—¥å¿—è¡¨ï¼ˆä¿ç•™è¯¦ç»†æ—¥å¿—ï¼‰
CREATE TABLE access_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    memory_id TEXT NOT NULL,
    access_type TEXT NOT NULL,  -- 'retrieval', 'used_in_response', 'user_mentioned'
    query TEXT,
    context TEXT,
    timestamp TEXT NOT NULL,
    FOREIGN KEY (memory_id) REFERENCES memories(id) ON DELETE CASCADE
);

-- è¿‡æœŸæ—¥å¿—è¡¨
CREATE TABLE expired_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    memory_id TEXT NOT NULL,
    content TEXT,
    expired_at TEXT NOT NULL,
    reason TEXT
);
```

### ç´¢å¼•è®¾è®¡

```sql
-- æ€§èƒ½å…³é”®ç´¢å¼•
CREATE INDEX idx_memories_type ON memories(type);
CREATE INDEX idx_memories_status ON memories(status);
CREATE INDEX idx_memories_importance ON memories(importance DESC);
CREATE INDEX idx_memories_score ON memories(score DESC);
CREATE INDEX idx_memories_created_at ON memories(created_at DESC);
CREATE INDEX idx_memories_last_accessed ON memories(last_accessed DESC);

-- å®ä½“æŸ¥è¯¢ç´¢å¼•
CREATE INDEX idx_entities_entity ON memory_entities(entity);
CREATE INDEX idx_entities_type ON memory_entities(entity_type);

-- å…³é”®è¯æŸ¥è¯¢ç´¢å¼•
CREATE INDEX idx_keywords_keyword ON memory_keywords(keyword);

-- è®¿é—®æ—¥å¿—ç´¢å¼•
CREATE INDEX idx_access_log_memory_id ON access_log(memory_id);
CREATE INDEX idx_access_log_timestamp ON access_log(timestamp DESC);
```

---

## ğŸ”„ è¿ç§»ç­–ç•¥

### Phase 1: æ•°æ®åº“åˆå§‹åŒ–

```python
import sqlite3
from pathlib import Path

def init_database(memory_dir: Path):
    """åˆå§‹åŒ– SQLite æ•°æ®åº“"""
    db_path = memory_dir / 'layer2' / 'memories.db'
    
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # åˆ›å»ºè¡¨ï¼ˆæ‰§è¡Œä¸Šé¢çš„ SQLï¼‰
    cursor.executescript(SCHEMA_SQL)
    
    conn.commit()
    conn.close()
    
    print(f"âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ: {db_path}")
```

### Phase 2: JSONL â†’ SQLite è¿ç§»

```python
def migrate_jsonl_to_sqlite(memory_dir: Path):
    """è¿ç§»ç°æœ‰ JSONL æ•°æ®åˆ° SQLite"""
    db_path = memory_dir / 'layer2' / 'memories.db'
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # è¿ç§» facts, beliefs, summaries
    for mem_type in ['facts', 'beliefs', 'summaries']:
        jsonl_path = memory_dir / 'layer2' / 'active' / f'{mem_type}.jsonl'
        
        if not jsonl_path.exists():
            continue
        
        with open(jsonl_path, 'r', encoding='utf-8') as f:
            for line in f:
                if not line.strip():
                    continue
                
                record = json.loads(line)
                
                # æ’å…¥ä¸»è¡¨
                cursor.execute('''
                    INSERT INTO memories (
                        id, type, content, importance, score,
                        created_at, updated_at, last_accessed, expires_at,
                        access_count, retrieval_count, used_in_response_count,
                        user_mentioned_count, access_boost,
                        conflict_downgraded, downgrade_reason, downgrade_at,
                        superseded, superseded_by,
                        is_permanent, status, metadata
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    record['id'],
                    mem_type[:-1],  # 'facts' -> 'fact'
                    record['content'],
                    record.get('importance', 0.5),
                    record.get('score', 1.0),
                    record['created_at'],
                    record.get('updated_at'),
                    record.get('last_accessed'),
                    record.get('expires_at'),
                    record.get('access_count', 0),
                    record.get('retrieval_count', 0),
                    record.get('used_in_response_count', 0),
                    record.get('user_mentioned_count', 0),
                    record.get('access_boost', 0.0),
                    1 if record.get('conflict_downgraded') else 0,
                    record.get('downgrade_reason'),
                    record.get('downgrade_at'),
                    1 if record.get('superseded') else 0,
                    record.get('superseded_by'),
                    1 if record.get('is_permanent', True) else 0,
                    'active',
                    json.dumps({k: v for k, v in record.items() 
                               if k not in CORE_FIELDS})  # å…¶ä»–å­—æ®µå­˜ metadata
                ))
                
                # æ’å…¥å®ä½“å…³è”
                for entity in record.get('entities', []):
                    cursor.execute('''
                        INSERT OR IGNORE INTO memory_entities (memory_id, entity)
                        VALUES (?, ?)
                    ''', (record['id'], entity))
                
                # æ’å…¥å…³é”®è¯
                for keyword in record.get('keywords', []):
                    cursor.execute('''
                        INSERT OR IGNORE INTO memory_keywords (memory_id, keyword)
                        VALUES (?, ?)
                    ''', (record['id'], keyword))
        
        print(f"âœ… è¿ç§»å®Œæˆ: {mem_type}")
    
    conn.commit()
    conn.close()
```

### Phase 3: å¤‡ä»½æ—§æ•°æ®

```python
def backup_jsonl(memory_dir: Path):
    """å¤‡ä»½åŸæœ‰ JSONL æ–‡ä»¶"""
    backup_dir = memory_dir / 'layer2' / 'jsonl_backup'
    backup_dir.mkdir(exist_ok=True)
    
    for mem_type in ['facts', 'beliefs', 'summaries']:
        src = memory_dir / 'layer2' / 'active' / f'{mem_type}.jsonl'
        if src.exists():
            dst = backup_dir / f'{mem_type}.jsonl.{now_iso()}'
            shutil.copy2(src, dst)
            print(f"âœ… å¤‡ä»½: {src} -> {dst}")
```

---

## ğŸ”§ æ ¸å¿ƒå‡½æ•°é‡å†™

### 1. è®¿é—®ç»Ÿè®¡æ›´æ–°ï¼ˆO(1) æ“ä½œï¼‰

```python
def update_memory_access_stats_sqlite(memory_id: str, access_type: str, memory_dir: Path):
    """æ›´æ–°è®¿é—®ç»Ÿè®¡ï¼ˆSQLite ç‰ˆæœ¬ï¼‰"""
    db_path = memory_dir / 'layer2' / 'memories.db'
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # O(1) å•è¡Œæ›´æ–°
    cursor.execute('''
        UPDATE memories
        SET access_count = access_count + 1,
            retrieval_count = retrieval_count + CASE WHEN ? = 'retrieval' THEN 1 ELSE 0 END,
            used_in_response_count = used_in_response_count + CASE WHEN ? = 'used_in_response' THEN 1 ELSE 0 END,
            user_mentioned_count = user_mentioned_count + CASE WHEN ? = 'user_mentioned' THEN 1 ELSE 0 END,
            last_accessed = ?
        WHERE id = ?
    ''', (access_type, access_type, access_type, now_iso(), memory_id))
    
    # è®°å½•è®¿é—®æ—¥å¿—
    cursor.execute('''
        INSERT INTO access_log (memory_id, access_type, timestamp)
        VALUES (?, ?, ?)
    ''', (memory_id, access_type, now_iso()))
    
    conn.commit()
    conn.close()
```

### 2. æ£€ç´¢æŸ¥è¯¢ï¼ˆç´¢å¼•åŠ é€Ÿï¼‰

```python
def search_memories_sqlite(query: str, memory_dir: Path, top_k: int = 10):
    """æ£€ç´¢è®°å¿†ï¼ˆSQLite ç‰ˆæœ¬ï¼‰"""
    db_path = memory_dir / 'layer2' / 'memories.db'
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row  # è¿”å›å­—å…¸
    cursor = conn.cursor()
    
    # æå–æŸ¥è¯¢å…³é”®è¯
    keywords = extract_keywords(query)
    entities = extract_entities(query)
    
    # æ„å»ºæŸ¥è¯¢ï¼ˆä½¿ç”¨ç´¢å¼•ï¼‰
    results = []
    
    # 1. å®ä½“ç²¾ç¡®åŒ¹é…
    if entities:
        placeholders = ','.join('?' * len(entities))
        cursor.execute(f'''
            SELECT m.*, GROUP_CONCAT(me.entity) as matched_entities
            FROM memories m
            JOIN memory_entities me ON m.id = me.memory_id
            WHERE me.entity IN ({placeholders})
              AND m.status = 'active'
            GROUP BY m.id
            ORDER BY m.score DESC, m.importance DESC
            LIMIT ?
        ''', (*entities, top_k))
        results.extend([dict(row) for row in cursor.fetchall()])
    
    # 2. å…³é”®è¯åŒ¹é…
    if keywords and len(results) < top_k:
        placeholders = ','.join('?' * len(keywords))
        cursor.execute(f'''
            SELECT m.*, GROUP_CONCAT(mk.keyword) as matched_keywords
            FROM memories m
            JOIN memory_keywords mk ON m.id = mk.memory_id
            WHERE mk.keyword IN ({placeholders})
              AND m.status = 'active'
              AND m.id NOT IN ({','.join('?' * len(results))})
            GROUP BY m.id
            ORDER BY COUNT(*) DESC, m.score DESC
            LIMIT ?
        ''', (*keywords, *[r['id'] for r in results], top_k - len(results)))
        results.extend([dict(row) for row in cursor.fetchall()])
    
    # 3. å…¨æ–‡æœç´¢ï¼ˆFTS5ï¼Œå¯é€‰ï¼‰
    # TODO: å¦‚æœéœ€è¦æ›´å¼ºçš„è¯­ä¹‰æœç´¢ï¼Œå¯ä»¥å¯ç”¨ FTS5
    
    conn.close()
    return results[:top_k]
```

### 3. å†²çªé™æƒï¼ˆäº‹åŠ¡ä¿è¯ï¼‰

```python
def downgrade_conflicting_memory_sqlite(old_id: str, new_id: str, tier: int, memory_dir: Path):
    """é™æƒå†²çªè®°å¿†ï¼ˆSQLite ç‰ˆæœ¬ï¼‰"""
    db_path = memory_dir / 'layer2' / 'memories.db'
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    penalty = 0.1 if tier == 1 else 0.4
    
    # äº‹åŠ¡ä¿è¯åŸå­æ€§
    cursor.execute('''
        UPDATE memories
        SET score = score * ?,
            conflict_downgraded = 1,
            downgrade_reason = ?,
            downgrade_at = ?
        WHERE id = ?
    ''', (penalty, new_id, now_iso(), old_id))
    
    conn.commit()
    conn.close()
```

---

## ğŸ§ª æµ‹è¯•è®¡åˆ’

### å•å…ƒæµ‹è¯•

```python
def test_sqlite_migration():
    """æµ‹è¯• JSONL â†’ SQLite è¿ç§»"""
    # 1. åˆ›å»ºæµ‹è¯• JSONL æ•°æ®
    # 2. æ‰§è¡Œè¿ç§»
    # 3. éªŒè¯æ•°æ®å®Œæ•´æ€§
    # 4. éªŒè¯ç´¢å¼•æ­£ç¡®æ€§
    pass

def test_access_update_performance():
    """æµ‹è¯•è®¿é—®æ›´æ–°æ€§èƒ½"""
    # å¯¹æ¯” JSONL vs SQLite çš„æ›´æ–°é€Ÿåº¦
    # é¢„æœŸï¼šSQLite å¿« 100x+
    pass

def test_search_performance():
    """æµ‹è¯•æ£€ç´¢æ€§èƒ½"""
    # å¯¹æ¯” JSONL vs SQLite çš„æŸ¥è¯¢é€Ÿåº¦
    # é¢„æœŸï¼šSQLite å¿« 10x+
    pass
```

### å‹åŠ›æµ‹è¯•

```python
def stress_test_10k_memories():
    """10K è®°å¿†å‹åŠ›æµ‹è¯•"""
    # æ’å…¥ 10,000 æ¡è®°å¿†
    # æ‰§è¡Œ 1,000 æ¬¡éšæœºè®¿é—®æ›´æ–°
    # æ‰§è¡Œ 1,000 æ¬¡éšæœºæŸ¥è¯¢
    # æµ‹é‡å¹³å‡å»¶è¿Ÿ
    pass
```

---

## ğŸ“‹ å®æ–½æ­¥éª¤

### Step 1: æ•°æ®åº“æ¨¡å—å¼€å‘ï¼ˆ4hï¼‰

- [ ] åˆ›å»º `sqlite_backend.py` æ¨¡å—
- [ ] å®ç°æ•°æ®åº“åˆå§‹åŒ–
- [ ] å®ç°æ ¸å¿ƒ CRUD æ“ä½œ
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•

### Step 2: è¿ç§»å·¥å…·å¼€å‘ï¼ˆ2hï¼‰

- [ ] å®ç° `migrate` å‘½ä»¤
- [ ] å®ç° JSONL å¤‡ä»½
- [ ] å®ç°æ•°æ®å®Œæ•´æ€§æ ¡éªŒ
- [ ] ç¼–å†™è¿ç§»æ–‡æ¡£

### Step 3: æ ¸å¿ƒå‡½æ•°é‡å†™ï¼ˆ4hï¼‰

- [ ] é‡å†™ `update_memory_access_stats`
- [ ] é‡å†™ `search_memories`
- [ ] é‡å†™ `cmd_consolidate` ç›¸å…³é€»è¾‘
- [ ] ä¿æŒå‘åå…¼å®¹ï¼ˆæ£€æµ‹ DB å­˜åœ¨æ€§ï¼‰

### Step 4: æµ‹è¯•å’ŒéªŒè¯ï¼ˆ2hï¼‰

- [ ] å•å…ƒæµ‹è¯•
- [ ] å‹åŠ›æµ‹è¯•
- [ ] è¿ç§»æµ‹è¯•ï¼ˆçœŸå®æ•°æ®ï¼‰
- [ ] æ€§èƒ½å¯¹æ¯”æŠ¥å‘Š

### Step 5: æ–‡æ¡£å’Œå‘å¸ƒï¼ˆ1hï¼‰

- [ ] æ›´æ–° README
- [ ] æ›´æ–° CHANGELOG
- [ ] å‘å¸ƒ v1.2.4

**æ€»è®¡**: ~13 å°æ—¶

---

## ğŸ¯ æˆåŠŸæŒ‡æ ‡

### æ€§èƒ½æŒ‡æ ‡

| æ“ä½œ | å½“å‰ (JSONL) | ç›®æ ‡ (SQLite) | å®é™… |
|------|-------------|--------------|------|
| 10K è®°å¿†è®¿é—®æ›´æ–° | ~500ms | <5ms | - |
| 10K è®°å¿†æŸ¥è¯¢ | ~200ms | <20ms | - |
| æ’å…¥æ–°è®°å¿† | ~1ms | ~1ms | - |

### è´¨é‡æŒ‡æ ‡

- âœ… é›¶æ•°æ®ä¸¢å¤±ï¼ˆè¿ç§»å‰åæ•°æ®ä¸€è‡´ï¼‰
- âœ… å‘åå…¼å®¹ï¼ˆæä¾› JSONL å¯¼å‡ºï¼‰
- âœ… æµ‹è¯•è¦†ç›–ç‡ >90%

---

## ğŸš¨ é£é™©å’Œç¼“è§£

### é£é™© 1: è¿ç§»å¤±è´¥å¯¼è‡´æ•°æ®ä¸¢å¤±

**ç¼“è§£**: 
- è¿ç§»å‰è‡ªåŠ¨å¤‡ä»½ JSONL
- è¿ç§»åæ ¡éªŒæ•°æ®å®Œæ•´æ€§
- æä¾›å›æ»šæœºåˆ¶

### é£é™© 2: SQLite æ–‡ä»¶æŸå

**ç¼“è§£**:
- å®šæœŸå¯¼å‡º JSONL å¤‡ä»½
- ä½¿ç”¨ WAL æ¨¡å¼ï¼ˆWrite-Ahead Loggingï¼‰
- æä¾›æ•°æ®åº“ä¿®å¤å·¥å…·

### é£é™© 3: æ€§èƒ½ä¸è¾¾é¢„æœŸ

**ç¼“è§£**:
- å……åˆ†çš„ç´¢å¼•è®¾è®¡
- æŸ¥è¯¢ä¼˜åŒ–ï¼ˆEXPLAIN QUERY PLANï¼‰
- å¿…è¦æ—¶ä½¿ç”¨ FTS5 å…¨æ–‡æœç´¢

---

## ğŸ“š å‚è€ƒèµ„æ–™

- SQLite å®˜æ–¹æ–‡æ¡£: https://www.sqlite.org/docs.html
- SQLite æ€§èƒ½ä¼˜åŒ–: https://www.sqlite.org/optoverview.html
- Python sqlite3 æ¨¡å—: https://docs.python.org/3/library/sqlite3.html

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2026-02-14  
**ä½œè€…**: [åŠ©æ‰‹]  
**å®¡æ ¸**: Crabby ğŸ¦€  
**çŠ¶æ€**: å¾…å®æ–½
