# Memory System v1.2.4 - SQLite è¿ç§»æ–¹æ¡ˆï¼ˆæœ€ç»ˆç‰ˆï¼‰

## ğŸ¯ è®¾è®¡åŸåˆ™

åŸºäºå¯¹è®°å¿†ç³»ç»Ÿæ ¸å¿ƒæœºåˆ¶çš„æ·±å…¥ç†è§£ï¼Œæœ¬æ–¹æ¡ˆéµå¾ªä»¥ä¸‹åŸåˆ™ï¼š

### 1. ä¿æŒä¸‰å±‚æ¶æ„çš„æœ¬è´¨
- Layer 1: å·¥ä½œè®°å¿†ï¼ˆå¿«ç…§ï¼ŒMarkdownï¼‰
- Layer 2: ç»“æ„åŒ–é•¿æœŸè®°å¿†ï¼ˆSQLite æ›¿ä»£ JSONLï¼‰
- Layer 3: åŸå§‹äº‹ä»¶æ—¥å¿—ï¼ˆä¿æŒä¸å˜ï¼‰

### 2. ä¼˜åŒ–æ ¸å¿ƒæµç¨‹
- **Consolidation**: 7 é˜¶æ®µæµç¨‹ä¿æŒä¸å˜ï¼Œåªæ”¹å­˜å‚¨åç«¯
- **Router Search**: å¤šè·¯æ£€ç´¢é€»è¾‘ä¿æŒï¼Œæ€§èƒ½æå‡
- **è®¿é—®ç»Ÿè®¡**: O(N) â†’ O(1)

### 3. æ”¯æŒç°æœ‰ç‰¹æ€§
- å®ä½“æå–å’Œå…³è”
- å†²çªæ£€æµ‹å’Œé™æƒ
- è®¿é—®åŠ æˆå’Œè¡°å‡
- QMD é›†æˆ
- Pending Buffer (Hot Store)

---

## ğŸ“Š æ ¸å¿ƒè¡¨è®¾è®¡

### è¡¨ 1: memoriesï¼ˆä¸»è¡¨ï¼‰

```sql
CREATE TABLE memories (
    -- ä¸»é”®
    id TEXT PRIMARY KEY,
    type TEXT NOT NULL CHECK(type IN ('fact', 'belief', 'summary')),
    
    -- æ ¸å¿ƒå†…å®¹
    content TEXT NOT NULL,
    
    -- è¯„åˆ†ç³»ç»Ÿ
    importance REAL DEFAULT 0.5,
    score REAL DEFAULT 1.0,
    final_score REAL GENERATED ALWAYS AS (score + access_boost) STORED,
    
    -- æ—¶é—´å­—æ®µ
    created TEXT NOT NULL,
    updated TEXT,
    last_accessed TEXT,
    
    -- è®¿é—®ç»Ÿè®¡
    access_count INTEGER DEFAULT 0,
    retrieval_count INTEGER DEFAULT 0,
    access_boost REAL DEFAULT 0.0,
    
    -- æ¥æºå’ŒçŠ¶æ€
    source TEXT,
    state INTEGER DEFAULT 0 CHECK(state IN (0, 1, 2)),  -- 0:Active, 1:Archived, 2:Junk
    
    -- å†²çªç®¡ç†
    conflict_downgraded INTEGER DEFAULT 0,
    downgrade_reason TEXT,
    superseded INTEGER DEFAULT 0,
    superseded_by TEXT,
    
    -- TTL ç®¡ç†
    ttl_days INTEGER,
    auto_delete_at TEXT,
    
    -- ç±»å‹ç‰¹æœ‰å­—æ®µ
    confidence REAL,
    basis TEXT,
    extract_method TEXT,
    expires_at TEXT,
    is_permanent INTEGER DEFAULT 1
);
```

### è¡¨ 2: memory_entitiesï¼ˆå®ä½“å…³è”ï¼‰

```sql
CREATE TABLE memory_entities (
    memory_id TEXT NOT NULL,
    entity TEXT NOT NULL,
    PRIMARY KEY (memory_id, entity),
    FOREIGN KEY (memory_id) REFERENCES memories(id) ON DELETE CASCADE
);
```

### è¡¨ 3: memory_relationsï¼ˆå…³ç³»ä¸‰å…ƒç»„ï¼‰

```sql
CREATE TABLE memory_relations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    memory_id TEXT NOT NULL,
    subject TEXT NOT NULL,
    relation_type TEXT NOT NULL,
    object TEXT NOT NULL,
    confidence REAL DEFAULT 1.0,
    created TEXT NOT NULL,
    superseded INTEGER DEFAULT 0,
    FOREIGN KEY (memory_id) REFERENCES memories(id) ON DELETE CASCADE
);
```

### è¡¨ 4: summary_sourcesï¼ˆæ‘˜è¦æ¥æºï¼‰

```sql
CREATE TABLE summary_sources (
    summary_id TEXT NOT NULL,
    source_fact_id TEXT NOT NULL,
    PRIMARY KEY (summary_id, source_fact_id),
    FOREIGN KEY (summary_id) REFERENCES memories(id) ON DELETE CASCADE
);
```

### è¡¨ 5: access_logï¼ˆè®¿é—®æ—¥å¿—ï¼Œå¯é€‰ï¼‰

```sql
CREATE TABLE access_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    memory_id TEXT NOT NULL,
    access_type TEXT NOT NULL,
    timestamp TEXT NOT NULL,
    FOREIGN KEY (memory_id) REFERENCES memories(id) ON DELETE CASCADE
);
```

---

## ğŸ” ç´¢å¼•è®¾è®¡

```sql
-- æ ¸å¿ƒæŸ¥è¯¢ç´¢å¼•
CREATE INDEX idx_memories_state_score ON memories(state, final_score DESC);
CREATE INDEX idx_memories_type ON memories(type);
CREATE INDEX idx_memories_created ON memories(created DESC);

-- TTL æ¸…ç†ç´¢å¼•
CREATE INDEX idx_memories_auto_delete ON memories(auto_delete_at) 
WHERE auto_delete_at IS NOT NULL;

-- å®ä½“æŸ¥è¯¢ç´¢å¼•
CREATE INDEX idx_entities_entity ON memory_entities(entity);

-- å…³ç³»æŸ¥è¯¢ç´¢å¼•
CREATE INDEX idx_relations_subject_type ON memory_relations(subject, relation_type, superseded);

-- è®¿é—®æ—¥å¿—ç´¢å¼•
CREATE INDEX idx_access_log_timestamp ON access_log(timestamp DESC);
```

---

## ğŸ”„ è¿ç§»ç­–ç•¥

### Phase 1: æ•°æ®åº“åˆå§‹åŒ–

```python
def init_sqlite_db(memory_dir: Path):
    """åˆå§‹åŒ– SQLite æ•°æ®åº“"""
    db_path = memory_dir / 'layer2/memories.db'
    conn = sqlite3.connect(db_path)
    
    # å¯ç”¨ WAL æ¨¡å¼ï¼ˆæå‡å¹¶å‘æ€§èƒ½ï¼‰
    conn.execute('PRAGMA journal_mode=WAL')
    conn.execute('PRAGMA synchronous=NORMAL')
    
    # åˆ›å»ºè¡¨å’Œç´¢å¼•
    conn.executescript(SCHEMA_SQL)
    conn.commit()
    conn.close()
```

### Phase 2: JSONL â†’ SQLite è¿ç§»

```python
def migrate_jsonl_to_sqlite(memory_dir: Path):
    """è¿ç§»ç°æœ‰ JSONL æ•°æ®"""
    db_path = memory_dir / 'layer2/memories.db'
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # å¼€å¯äº‹åŠ¡ï¼ˆæ‰¹é‡å†™å…¥ä¼˜åŒ–ï¼‰
    cursor.execute('BEGIN TRANSACTION')
    
    for mem_type in ['facts', 'beliefs', 'summaries']:
        jsonl_path = memory_dir / 'layer2/active' / f'{mem_type}.jsonl'
        if not jsonl_path.exists():
            continue
        
        records = load_jsonl(jsonl_path)
        for record in records:
            # æ’å…¥ä¸»è¡¨
            cursor.execute('''
                INSERT OR REPLACE INTO memories (
                    id, type, content, importance, score,
                    created, last_accessed, access_count, retrieval_count,
                    access_boost, source, state
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                record['id'],
                mem_type[:-1],
                record['content'],
                record.get('importance', 0.5),
                record.get('score', 1.0),
                record.get('created', record.get('created_at')),
                record.get('last_accessed'),
                record.get('access_count', 0),
                record.get('retrieval_count', 0),
                record.get('access_boost', 0.0),
                record.get('source', 'unknown'),
                0  # Active
            ))
            
            # æ’å…¥å®ä½“
            for entity in record.get('entities', []):
                cursor.execute('''
                    INSERT OR IGNORE INTO memory_entities (memory_id, entity)
                    VALUES (?, ?)
                ''', (record['id'], entity))
    
    cursor.execute('COMMIT')
    conn.close()
```

---

## ğŸš€ æ ¸å¿ƒåŠŸèƒ½é‡å†™

### 1. è®¿é—®ç»Ÿè®¡æ›´æ–°ï¼ˆO(1)ï¼‰

```python
def update_access_stats(memory_id: str, access_type: str, memory_dir: Path):
    """O(1) è®¿é—®ç»Ÿè®¡æ›´æ–°"""
    conn = sqlite3.connect(memory_dir / 'layer2/memories.db')
    cursor = conn.cursor()
    
    cursor.execute('''
        UPDATE memories
        SET access_count = access_count + 1,
            retrieval_count = retrieval_count + CASE WHEN ? = 'retrieval' THEN 1 ELSE 0 END,
            last_accessed = ?
        WHERE id = ?
    ''', (access_type, now_iso(), memory_id))
    
    conn.commit()
    conn.close()
```

### 2. Router Searchï¼ˆå¤šè·¯æ£€ç´¢ï¼‰

```python
def router_search_sqlite(query: str, memory_dir: Path, top_k: int = 10):
    """SQLite ç‰ˆæœ¬çš„ router_search"""
    conn = sqlite3.connect(memory_dir / 'layer2/memories.db')
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    # æå–æŸ¥è¯¢ç‰¹å¾
    entities = extract_entities(query)
    
    # 1. å®ä½“ç²¾ç¡®åŒ¹é…ï¼ˆé«˜ç½®ä¿¡åº¦ï¼‰
    if entities:
        cursor.execute('''
            SELECT m.*, GROUP_CONCAT(me.entity) as matched_entities
            FROM memories m
            JOIN memory_entities me ON m.id = me.memory_id
            WHERE me.entity IN ({})
              AND m.state = 0
            GROUP BY m.id
            ORDER BY m.final_score DESC
            LIMIT ?
        '''.format(','.join('?' * len(entities))), (*entities, top_k))
        
        results = [dict(row) for row in cursor.fetchall()]
        
        # é«˜ç½®ä¿¡åº¦ç›´æ¥è¿”å›
        if results and results[0]['final_score'] > 0.85:
            conn.close()
            return results
    
    # 2. å…¨æ–‡æœç´¢ï¼ˆå¦‚æœå®ä½“åŒ¹é…ä¸è¶³ï¼‰
    # TODO: å¯é€‰ FTS5 å…¨æ–‡æœç´¢
    
    conn.close()
    return results
```

### 3. å†²çªè§£å†³ï¼ˆå…³ç³»è¡¨ï¼‰

```python
def resolve_relation_conflict(subject: str, relation_type: str, new_object: str, memory_id: str, memory_dir: Path):
    """åŸºäºå…³ç³»è¡¨çš„å†²çªè§£å†³"""
    conn = sqlite3.connect(memory_dir / 'layer2/memories.db')
    cursor = conn.cursor()
    
    # 1. æ ‡è®°æ—§å…³ç³»ä¸º superseded
    cursor.execute('''
        UPDATE memory_relations
        SET superseded = 1
        WHERE subject = ?
          AND relation_type = ?
          AND superseded = 0
    ''', (subject, relation_type))
    
    # 2. æ’å…¥æ–°å…³ç³»
    cursor.execute('''
        INSERT INTO memory_relations (memory_id, subject, relation_type, object, created)
        VALUES (?, ?, ?, ?, ?)
    ''', (memory_id, subject, relation_type, new_object, now_iso()))
    
    conn.commit()
    conn.close()
```

### 4. TTL æ¸…ç†

```python
def ttl_cleanup(memory_dir: Path):
    """TTL ç¡¬åˆ é™¤"""
    conn = sqlite3.connect(memory_dir / 'layer2/memories.db')
    cursor = conn.cursor()
    
    cursor.execute('''
        UPDATE memories
        SET state = 2  -- Junk
        WHERE auto_delete_at IS NOT NULL
          AND auto_delete_at < datetime('now')
          AND state = 0
    ''')
    
    deleted = cursor.rowcount
    conn.commit()
    conn.close()
    
    return deleted
```

---

## ğŸ“‹ å®æ–½è®¡åˆ’

### Step 1: æ•°æ®åº“æ¨¡å—ï¼ˆ4hï¼‰
- [ ] åˆ›å»º `sqlite_backend.py`
- [ ] å®ç°è¡¨åˆå§‹åŒ–
- [ ] å®ç°åŸºç¡€ CRUD

### Step 2: è¿ç§»å·¥å…·ï¼ˆ2hï¼‰
- [ ] å®ç° `migrate` å‘½ä»¤
- [ ] JSONL å¤‡ä»½
- [ ] æ•°æ®å®Œæ•´æ€§æ ¡éªŒ

### Step 3: æ ¸å¿ƒå‡½æ•°é‡å†™ï¼ˆ4hï¼‰
- [ ] é‡å†™è®¿é—®ç»Ÿè®¡
- [ ] é‡å†™ router_search
- [ ] é‡å†™ consolidate å­˜å‚¨é€»è¾‘

### Step 4: å…³ç³»æå–ï¼ˆ3hï¼‰
- [ ] å®ç°å…³ç³»æå–é€»è¾‘
- [ ] é›†æˆåˆ° Phase 3
- [ ] å†²çªè§£å†³æµ‹è¯•

### Step 5: æµ‹è¯•ï¼ˆ2hï¼‰
- [ ] å•å…ƒæµ‹è¯•
- [ ] æ€§èƒ½æµ‹è¯•
- [ ] è¿ç§»æµ‹è¯•

**æ€»è®¡**: ~15 å°æ—¶

---

## ğŸ¯ æˆåŠŸæŒ‡æ ‡

| æŒ‡æ ‡ | å½“å‰ | ç›®æ ‡ |
|------|------|------|
| 10K è®°å¿†è®¿é—®æ›´æ–° | ~500ms | <5ms |
| å®ä½“æŸ¥è¯¢ | ~200ms | <20ms |
| å†²çªè§£å†³å‡†ç¡®ç‡ | ~70% | >95% |

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2026-02-14  
**ä½œè€…**: [åŠ©æ‰‹]
